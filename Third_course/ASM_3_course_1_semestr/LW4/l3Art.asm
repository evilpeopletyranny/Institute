p1 macro f1		; Bывод сообщений на экран
	push ax
	push dx
	mov dx, offset f1
	mov ah, 09h
	mov ah, 09h
	int 21h
	pop dx
	pop ax
endm


p2 macro f2 	; Bвод строки символов
	push ax
	push dx
	mov dx, offset f2
	mov ah, 0Ah
	int 21h
	pop dx
	pop ax
endm

d1 SEGMENT para public 'data'

	mess1 db 'Input number: $'
	
	in_str label byte 	; Cтрока символов (не более 6)
	razmer db 7
	kol db (?)
	stroka db 7 dup (?)
	
	
	number dw 5 dup (0)   ; Mассив чисел
	
	siz dw 5              ; Kоличество чисел
	
	negNum dw 5 dup (0)
	posNum dw 5 dup (0)
	sum dw 5 dup(0)
	
	perevod db 10,13,'$'
	text_err1 db 'Input Error!', 10,10,'$'
	div_zero db 'Divition by zero!', 10,10,'$'
	messovf db 13,10,7,'Overflow!','$'
	MulNeg db 13,10,'Mul of negatives: ','$'
	messageMinChet db 13,10,'Min of even: ','$'
	star db '*  $'
	equal db '=  $'
	
	out_str db 6 dup (' '),'$'
	
	flag_err equ 1
	
d1 ENDS



c1 SEGMENT para public 'code'
ASSUME cs:c1, ds:d1, ss:st1

start:	
	mov ax, d1
	mov ds, ax
	
	;Установка текстового видеорежима, очистка экрана
	mov ax, 03h  	;ah=0 (номер функции),al=3 (номер режима)
	int 10h

    xor di,di
    mov cx, siz 	; В cx - размер массива
	
vvod:	
	push cx

m1:	
	p1 mess1    ; Вывод сообщения о вводе строки
	p2 in_str 	; Ввод числа в виде строки
	
	p1 perevod
	
	call diapazon	; Проверка диапазона вводимых чисел (-29999,+29999)
	
	cmp bh, flag_err  	; Сравним bh и flag_err
	je err1         	; Если равен -сообщение об ошибке ввода
	

	call dopust		; Проверка допустимости вводимых символов
	
	cmp bh, flag_err
	je err1
	
	call AscToBin 	; Преобразование строки в число
	inc di
	inc di
	pop cx
	loop vvod
	jmp m2
	
err1:   
	p1 text_err1	
	jmp endprog
	
; ->>>>>>>>>>>>>>>>>>>>>>>>> арифметическая обработка <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<-----------------
m2:	
	mov cx, siz 	; В (cx) - размер массива
	mov si, offset number
	mov di, offset negNum
	xor bx, bx
negFind:	
	mov ax, [si]
	cmp ax, 0
	jge endNegFind
	mov [di], ax
	inc di
	inc di
	inc bl
	
endNegFind:
	inc si
	inc si
	loop negFind
	
	mov cx, siz
	mov si, offset number
	mov di, offset posNum
	
posFind:	
	mov ax, [si]
	cmp ax, 0
	jl endPosFind
	mov [di], ax
	inc di
	inc di
	inc bh
	
endPosFind:
	inc si
	inc si
	loop posFind
	
	xor cx, cx
	
	cmp bl, bh
	jge bhLess
	mov cl, bl
	jmp blLess
bhLess:
	mov cl, bh
	
blLess:

	cmp cx, 00h
	jne _clearDI
	jmp endprog
	
	
	
_clearDI:
	xor di, di
	
mainLoop:
	mov ax, posNum[di]
	call BinToAsc
	p1 out_str
	call clearOutputStr
	
	p1 star
	
	mov ax, negNum[di]
	call BinToAsc
	p1 out_str
	call clearOutputStr

	p1 equal

	mov ax, posNum[di]
	mov bx, negNum[di]
	imul bx
	jo overflow

	add sum, ax
	
	call BinToAsc
	p1 out_str
	call clearOutputStr
	
	p1 perevod
	
	
	inc di
	inc di
	loop mainLoop
	jmp sumOut
	jmp endprog

sumOut:
	p1 perevod
	mov ax, sum
	call BinToAsc
	p1 out_str
	call clearOutputStr
	jmp endprog
		
zero:
		p1 div_zero
		jmp endprog
		
		
overflow:
		p1 messovf
		
		
endprog:
			mov ax, 4c00h
			int 21h
	
	
;****************************************************
;* Проверка диапазона вводимых чисел -29999,+29999	*
;* Аргументы:										*
;* 		Буфер ввода - stroka						*
;* 													*
;* Результат:										*
;* 		bh - флаг ошибки ввода						*
;****************************************************
	
DIAPAZON PROC
    xor bh, bh
	xor si, si
	
	cmp kol, 05h 	; Если ввели менее 5 символов, проверим их допустимость
	jb dop
		
	cmp stroka, 2dh 	; Eсли ввели 5 или более символов проверим является ли первый минусом
	jne plus 	; Eсли 1 символ не минус, проверим число символов
	
	cmp kol, 06h 	; Eсли первый - минус и символов меньше 6 проверим допустимость символов 
	jb dop        
	
	inc si		; Иначе проверим первую цифру
	jmp first

plus:   
	cmp kol,6	; Bведено 6 символов и первый - не минус 
	je error1	; Oшибка
	
first:  
	cmp stroka[si], 32h	; Cравним первый символ с '2'
	jna dop		; Eсли первый <= '2' - проверим допустимость символов
	
error1:
	mov bh, flag_err	; Иначе bh = flag_err
	
dop:	
	ret
DIAPAZON ENDP


;****************************************************
;* Проверка допустимости вводимых символов			*
;* Аргументы:										*
;* 		Буфер ввода - stroka						*
;*		si - номер символа в строке					*
;* 													*
;* Результат:										*
;* 		bh - флаг ошибки ввода						*
;****************************************************
DOPUST PROC

	xor bh, bh
    xor si, si
	xor ah, ah
	xor ch, ch
	
	mov cl, kol	; В (cl) количество введенных символов
	
m11:	
	mov al, [stroka + si] 	; B (al) - первый символ
	cmp al, 2dh	; Является ли символ минусом
	jne testdop	; Если не минус - проверка допустимости
	cmp si, 00h	; Если минус  - является ли он первым символом
	jne error2	; Если минус не первый - ошибка
	jmp m13
	
testdop:
	cmp al, 30h	;Является ли введенный символ цифрой
	jb error2
	cmp al, 39h
	ja error2
	
m13: 	
	inc si
	loop m11
	jmp m14
	
error2:	
	mov bh, flag_err	; При недопустимости символа bh = flag_err
	
m14:	
	ret
DOPUST ENDP

;****************************************************
;* ASCII to number									*
;* Аргументы:										*
;* 		B cx количество введенных символов			*
;*		B bx - номер символа начиная с последнего 	*
;* 													*
;* Результат:										*
;* 		Буфер чисел - number						*
;*		B di - номер числа в массиве				*
;****************************************************
AscToBin PROC
	xor ch, ch
	mov cl, kol
	xor bh, bh
	mov bl, cl
	dec bl
	mov si, 01h  ; В si вес разряда
	
n1:	
	mov al, [stroka + bx]
	xor ah, ah
	cmp al, 2dh	; Проверим знак числа
	je otr	; Eсли число отрицательное
	sub al,	30h
	mul si
	add [number + di], ax
	mov ax, si
	mov si, 10
	mul si
	mov si, ax
	dec bx
	loop n1
	jmp n2
otr:	
	neg [number + di]	; Представим отрицательное число в дополнительном коде
	
n2:	
	ret
AscToBin ENDP

;****************************************************
;* Number to ASCII									*
;* Аргументы:										*
;* 		Число передается через ax					*
;* 													*
;* Результат:										*
;* 		Буфер чисел - out_str						*
;****************************************************
BinToAsc PROC
	xor si, si
	add si, 05h
	mov bx, 0Ah
	push ax
	cmp ax, 00h
	jnl mm1
	neg ax
	
mm1:	
	cwd
	idiv bx
	add dl,30h
	mov [out_str + si], dl
	dec si
	cmp ax, 00h
	jne mm1
	pop ax
	cmp ax, 00h
	jge mm2
	mov [out_str + si], 2dh
	
mm2:	
	ret
BinToAsc ENDP

clearOutputStr PROC
	xor si, si
	mov si, offset out_str
	push cx
	mov cl, 06h
_clearCycle:
	mov [si], byte ptr ' '
	inc si
	loop _clearCycle
	pop cx
	ret
ENDP
      
	  
c1 ENDS		
st1 SEGMENT para stack 'stack'
	dw 10 dup (?)
st1 ENDS

end start